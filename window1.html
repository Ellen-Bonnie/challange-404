<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Parse XML with DMS Coordinates</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    h2 {
      text-align: center;
    }

    textarea {
      width: 100%;
      height: 300px;
      margin-bottom: 10px;
      font-family: monospace;
      resize: vertical;
    }

    /* Upload zone */
    #dropZone {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      border: 2px dashed #ccc;
      border-radius: 10px;
      padding: 10px;
      transition: background 0.3s, border-color 0.3s;
    }

    #dropZone.dragover {
      border-color: #007bff;
      background: #eef7ff;
    }

    /* Button Container */
    .button-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 40px;
    }

    .donate-container {
      display: flex;
      justify-content: flex-end;
      margin-top: 10px;
      margin-bottom: 20px;
    }

    .donate-image {
      width: 220px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    /* Fancy Buttons */
    .fancy-button {
      width: 25%;
      border: none;
      border-radius: 43px;
      background: linear-gradient(to right, #fe606f, #feb174);
      color: white;
      font-size: 18px;
      font-weight: 800;
      text-transform: uppercase;
      cursor: pointer;
      text-align: center;
      line-height: 60px;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
      box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15);
    }

    .fancy-button:hover {
      transform: translateY(-2px);
      filter: brightness(1.08);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    .fancy-button.small {
      width: auto;
      padding: 10px 20px;
      line-height: normal;
      font-size: 16px;
      border-radius: 30px;
    }

    #result {
      background: #f9f9f9;
      padding: 15px;
      border: 1px solid #ccc;
      margin-top: 20px;
      white-space: pre-wrap;
      font-family: monospace;
      flex-grow: 1;
    }

    #quoteBox {
      text-align: center;
      color: #12007a;
      font-size: 28px;
      font-style: italic;
      margin-top: 20px;
      margin-bottom: 25px;
      transition: opacity 0.5s ease;
    }

    .bullet { font-weight: bold; margin-right: 6px; }
    .area { color: #e6b800; }
    .line { color: #007bff; }
    .circle { color: #28a745; }
    .coast { color: #8b4513; }
    .label { color: #9b59b6; }
    .userchart { color: #ff6600; font-weight: bold; }
    .clearing { color: #00bcd4; }
    .tidal { color: #ff1493; }
  </style>
</head>
<body>

<h2>XML Coordinate Parser (Areas, Lines, Circles, Coast Lines, Labels, Clearing Lines, Tidals, UserChart)</h2>

<div id="dropZone">
  <textarea id="xmlInput" placeholder="Paste your XML here or drop XML file here..."></textarea>
  <input type="file" id="fileInput" accept=".xml" hidden />
  <button class="fancy-button small" onclick="document.getElementById('fileInput').click()">Upload XML File</button>
</div>

<div class="button-container">
  <button class="fancy-button" onclick="parseXML()">Parse XML</button>
  <button class="fancy-button" onclick="downloadTextFile()">Download .txt</button>
</div>

<div class="donate-container">
  <img src="photo_5440463335184268274_y.jpg" alt="Buy me a coffee QR" class="donate-image">
</div>

<div id="quoteBox">Loading quote...</div>

<div id="result"></div>

<script>
  let parsedOutput = '';
  let quotes = [];

  // Load quotes from external file
  fetch('motivational_quotes.txt')
    .then(response => response.text())
    .then(text => {
      quotes = text.split('\n').map(q => q.trim()).filter(q => q.length > 0);
      showRandomQuote();
    })
    .catch(() => {
      document.getElementById("quoteBox").textContent = "Stay motivated — your quotes file couldn't be loaded!";
    });

  function showRandomQuote() {
    const box = document.getElementById("quoteBox");
    if (quotes.length === 0) return;
    box.style.opacity = 0;
    setTimeout(() => {
      const randomIndex = Math.floor(Math.random() * quotes.length);
      box.textContent = quotes[randomIndex];
      box.style.opacity = 1;
    }, 300);
  }

  function toDM(deg, isLat) {
    const absolute = Math.abs(deg);
    const degrees = Math.floor(absolute);
    const minutes = (absolute - degrees) * 60;
    const direction = deg >= 0 ? (isLat ? "N" : "E") : (isLat ? "S" : "W");
    const degStr = degrees < 10 ? "0" + degrees : degrees.toString();
    const minStr = minutes < 10 ? "0" + minutes.toFixed(3) : minutes.toFixed(3);
    return `${degStr}°${minStr}′ ${direction}`;
  }

  function parseXML() {
    showRandomQuote();

    const xmlString = document.getElementById('xmlInput').value;
    if (!xmlString.trim()) {
      document.getElementById('result').textContent = 'Please paste XML data first.';
      return;
    }

    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");
      if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        document.getElementById('result').textContent = 'Error parsing XML. Please check the format.';
        return;
      }

      let htmlOutput = '';
      let textOutput = '';

      const usercharts = xmlDoc.getElementsByTagName('userchart');
      if (usercharts.length > 0) {
        for (let chart of usercharts) {
          const chartName = chart.getAttribute('name') || '(No name)';
          htmlOutput += `<span class="userchart">UserChart name: ${chartName}</span>\n`;
          textOutput += `UserChart name: ${chartName}\n`;
          processElements(chart);
        }
      } else {
        processElements(xmlDoc);
      }

      function processElements(root) {
        // AREA
        const areas = root.getElementsByTagName('area');
        for (let area of areas) {
          const name = area.getAttribute('name') || '(No name)';
          htmlOutput += `<span class="bullet area">•</span>AREA: ${name}\n`;
          textOutput += `AREA: ${name}\n`;
          for (let v of area.getElementsByTagName('vertex')) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  ${coord}\n`;
            textOutput += `  ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }

        // LINE
        const lines = root.getElementsByTagName('line');
        for (let line of lines) {
          const name = line.getAttribute('name') || '(No name)';
          const attr = line.querySelector('attribute');
          const type = attr ? attr.getAttribute('lineType') : '(no type)';
          htmlOutput += `<span class="bullet line">•</span>LINE: ${name}\n  Type: ${type}\n`;
          textOutput += `LINE: ${name}\n  Type: ${type}\n`;
          for (let v of line.getElementsByTagName('vertex')) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  ${coord}\n`;
            textOutput += `  ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }

        // CLEARING LINE
        const clearings = root.getElementsByTagName('clearingLine');
        for (let cl of clearings) {
          const name = cl.getAttribute('name') || '(No name)';
          const desc = cl.getAttribute('description') || '';
          const attr = cl.querySelector('attribute');
          const lineType = attr ? attr.getAttribute('lineType') : '(no lineType)';
          const typeTag = cl.querySelector('type');
          const isDanger = typeTag ? typeTag.getAttribute('isDanger') : '(no isDanger)';

          htmlOutput += `<span class="bullet clearing">•</span>CLEARING LINE: ${name}\n  Description: ${desc}\n  LineType: ${lineType}\n  IsDanger: ${isDanger}\n`;
          textOutput += `CLEARING LINE: ${name}\n  Description: ${desc}\n  LineType: ${lineType}\n  IsDanger: ${isDanger}\n`;

          for (let v of cl.getElementsByTagName('vertex')) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  ${coord}\n`;
            textOutput += `  ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }

        // CIRCLE
        const circles = root.getElementsByTagName('circle');
        for (let circle of circles) {
          const name = circle.getAttribute('name') || '(No name)';
          const attr = circle.querySelector('attribute');
          let range = attr ? attr.getAttribute('range') : '(no range)';
          if (!isNaN(range)) range = parseFloat(range).toFixed(2);
          htmlOutput += `<span class="bullet circle">•</span>CIRCLE: ${name}\n  Range: ${range} NM\n`;
          textOutput += `CIRCLE: ${name}\n  Range: ${range} NM\n`;
          const v = circle.querySelector('vertex');
          if (v) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  Center: ${coord}\n`;
            textOutput += `  Center: ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }

        // TIDAL
        const tidals = root.getElementsByTagName('tidal');
        for (let tidal of tidals) {
          const name = tidal.getAttribute('name') || '(No name)';
          const desc = tidal.getAttribute('description') || '';
          const attr = tidal.querySelector('attribute');
          const orientation = attr ? attr.getAttribute('orientation') : '(no orientation)';
          const typeVal = attr ? attr.getAttribute('type') : '(no type)';
          const strength = attr ? attr.getAttribute('strength') : '(no strength)';
          const time = attr ? attr.getAttribute('time') : '(no time)';

          htmlOutput += `<span class="bullet tidal">•</span>TIDAL: ${name}\n  Description: ${desc}\n  Orientation: ${orientation}\n  Type: ${typeVal}\n  Strength: ${strength}\n  Time: ${time}\n`;
          textOutput += `TIDAL: ${name}\n  Description: ${desc}\n  Orientation: ${orientation}\n  Type: ${typeVal}\n  Strength: ${strength}\n  Time: ${time}\n`;

          const v = tidal.querySelector('vertex');
          if (v) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  Position: ${coord}\n`;
            textOutput += `  Position: ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }

        // LABEL
        const labels = root.getElementsByTagName('label');
        for (let label of labels) {
          const name = label.getAttribute('name') || '(No name)';
          const text = label.textContent.trim() || '(no text)';
          const v = label.querySelector('vertex');
          htmlOutput += `<span class="bullet label">•</span>LABEL: ${name}\n  Text: ${text}\n`;
          textOutput += `LABEL: ${name}\n  Text: ${text}\n`;
          if (v) {
            const lat = parseFloat(v.getAttribute('latitude'));
            const lon = parseFloat(v.getAttribute('longitude'));
            const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
            htmlOutput += `  Position: ${coord}\n`;
            textOutput += `  Position: ${coord}\n`;
          }
          htmlOutput += '\n';
          textOutput += '\n';
        }
      }

      parsedOutput = textOutput;
      document.getElementById('result').innerHTML = htmlOutput || 'No recognized elements found.';
    } catch (error) {
      document.getElementById('result').textContent = `Error: ${error.message}`;
    }
  }

  function downloadTextFile() {
    if (!parsedOutput) {
      alert("Nothing to download. Please parse XML first.");
      return;
    }
    const blob = new Blob([parsedOutput], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'parsed_coordinates.txt';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // === File upload and drag-drop support ===
  const fileInput = document.getElementById('fileInput');
  const dropZone = document.getElementById('dropZone');
  const xmlInput = document.getElementById('xmlInput');

  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) readXMLFile(file);
  });

  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('dragover');
  });
  dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file && file.name.endsWith('.xml')) readXMLFile(file);
    else alert('Please drop a valid .xml file');
  });

  function readXMLFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      xmlInput.value = e.target.result;
      parseXML();
    };
    reader.readAsText(file);
  }
</script>

</body>
</html>
