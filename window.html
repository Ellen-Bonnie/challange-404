<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Parse XML with DMS Coordinates</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #fafafa; }
    textarea { width: 100%; height: 300px; margin-bottom: 10px; font-family: monospace; }
    button { padding: 10px 20px; margin-right: 10px; cursor: pointer; }
    #result { white-space: pre-wrap; background: #f9f9f9; padding: 15px; border: 1px solid #ccc; margin-top: 20px; }
  </style>
</head>
<body>

<h2> <3 XML Coordinate Parser <3 (Areas, Lines, Circles, Coast Lines, Labels)</h2>

<textarea id="xmlInput" placeholder="Paste your XML here..."></textarea>
<br>
<button onclick="parseXML()">Parse XML</button>
<button onclick="downloadTextFile()">Download .txt</button>

<div id="result"></div>

<script>
  let parsedOutput = '';

  // Convert decimal degrees ‚Üí degrees + decimal minutes (zero-padded, 3 decimals)
  function toDM(deg, isLat) {
    const absolute = Math.abs(deg);
    const degrees = Math.floor(absolute);
    const minutes = (absolute - degrees) * 60;
    const direction = deg >= 0
      ? (isLat ? "N" : "E")
      : (isLat ? "S" : "W");

    // Zero-padding for degrees (<10) and minutes (<10)
    const degStr = degrees < 10 ? "0" + degrees : degrees.toString();
    const minStr = minutes < 10 ? "0" + minutes.toFixed(3) : minutes.toFixed(3);

    return `${degStr}¬∞${minStr}‚Ä≤ ${direction}`;
  }

  function parseXML() {
    const xmlString = document.getElementById('xmlInput').value;
    if (!xmlString.trim()) {
      document.getElementById('result').textContent = 'Please paste XML data first.';
      return;
    }

    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");

      if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        document.getElementById('result').textContent = 'Error parsing XML. Please check the format.';
        return;
      }

      let output = '';

      // üü® Areas
      const areas = xmlDoc.getElementsByTagName('area');
      for (let area of areas) {
        const name = area.getAttribute('name') || '(No name)';
        output += `üü® AREA: ${name}\n`;
        const vertices = area.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          output += `  ${toDM(lat, true)}, ${toDM(lon, false)}\n`;
        }
        output += '\n';
      }

      // üü¶ Lines
      const lines = xmlDoc.getElementsByTagName('line');
      for (let line of lines) {
        const name = line.getAttribute('name') || '(No name)';
        const attr = line.querySelector('attribute');
        const type = attr ? attr.getAttribute('lineType') : '(no type)';
        output += `üü¶ LINE: ${name}\n  Type: ${type}\n`;
        const vertices = line.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          output += `  ${toDM(lat, true)}, ${toDM(lon, false)}\n`;
        }
        output += '\n';
      }

      // üîµ Circles
      const circles = xmlDoc.getElementsByTagName('circle');
      for (let circle of circles) {
        const name = circle.getAttribute('name') || '(No name)';
        const attr = circle.querySelector('attribute');
        let range = attr ? attr.getAttribute('range') : '(no range)';
        if (!isNaN(range)) range = parseFloat(range).toFixed(2);
        output += `üîµ CIRCLE: ${name}\n  Range: ${range} NM\n`;

        const v = circle.querySelector('vertex');
        if (v) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          output += `  Center: ${toDM(lat, true)}, ${toDM(lon, false)}\n`;
        }
        output += '\n';
      }

      // üü´ Coast Lines
      const coasts = xmlDoc.getElementsByTagName('coastline');
      for (let coast of coasts) {
        const name = coast.getAttribute('name') || '(No name)';
        output += `üü´ COAST LINE: ${name}\n`;
        const vertices = coast.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          output += `  ${toDM(lat, true)}, ${toDM(lon, false)}\n`;
        }
        output += '\n';
      }

      // üè∑Ô∏è Labels
      const labels = xmlDoc.getElementsByTagName('label');
      for (let label of labels) {
        const name = label.getAttribute('name') || '(No name)';
        const text = label.textContent.trim() || '(no text)';
        const v = label.querySelector('vertex');
        output += `üè∑Ô∏è LABEL: ${name}\n  Text: ${text}\n`;
        if (v) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          output += `  Position: ${toDM(lat, true)}, ${toDM(lon, false)}\n`;
        }
        output += '\n';
      }

      parsedOutput = output;
      document.getElementById('result').textContent = output || 'No recognized elements found.';
    } catch (error) {
      document.getElementById('result').textContent = `Error: ${error.message}`;
    }
  }

  function downloadTextFile() {
    if (!parsedOutput) {
      alert("Nothing to download. Please parse XML first.");
      return;
    }
    const blob = new Blob([parsedOutput], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'parsed_coordinates.txt';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
</script>

</body>
</html>
