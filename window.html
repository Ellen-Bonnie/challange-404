<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Parse XML with DMS Coordinates</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #fafafa; }
    textarea { width: 100%; height: 300px; margin-bottom: 10px; font-family: monospace; }
    button { padding: 10px 20px; margin-right: 10px; cursor: pointer; }
    #result { background: #f9f9f9; padding: 15px; border: 1px solid #ccc; margin-top: 20px; white-space: pre-wrap; font-family: monospace; }
    .bullet { font-weight: bold; margin-right: 6px; }
    .area { color: #e6b800; }       /* Yellow */
    .line { color: #007bff; }       /* Blue */
    .circle { color: #28a745; }     /* Green */
    .coast { color: #8b4513; }      /* Brown */
    .label { color: #9b59b6; }      /* Purple */
  </style>
</head>
<body>

<h2> <3 XML Coordinate Parser ;) (Areas, Lines, Circles, Coast Lines, Labels)</h2>

<textarea id="xmlInput" placeholder="Paste your XML here..."></textarea>
<br>
<button onclick="parseXML()">Parse XML</button>
<button onclick="downloadTextFile()">Download .txt</button>

<div id="result"></div>

<script>
  let parsedOutput = '';

  // Convert decimal degrees â†’ degrees + decimal minutes (zero-padded, 3 decimals)
  function toDM(deg, isLat) {
    const absolute = Math.abs(deg);
    const degrees = Math.floor(absolute);
    const minutes = (absolute - degrees) * 60;
    const direction = deg >= 0
      ? (isLat ? "N" : "E")
      : (isLat ? "S" : "W");

    const degStr = degrees < 10 ? "0" + degrees : degrees.toString();
    const minStr = minutes < 10 ? "0" + minutes.toFixed(3) : minutes.toFixed(3);

    return `${degStr}Â°${minStr}â€² ${direction}`;
  }

  function parseXML() {
    const xmlString = document.getElementById('xmlInput').value;
    if (!xmlString.trim()) {
      document.getElementById('result').textContent = 'Please paste XML data first.';
      return;
    }

    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");

      if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        document.getElementById('result').textContent = 'Error parsing XML. Please check the format.';
        return;
      }

      let htmlOutput = '';
      let textOutput = '';

      // ðŸŸ¡ Areas
      const areas = xmlDoc.getElementsByTagName('area');
      for (let area of areas) {
        const name = area.getAttribute('name') || '(No name)';
        htmlOutput += `<span class="bullet area">â€¢</span>AREA: ${name}\n`;
        textOutput += `AREA: ${name}\n`;
        const vertices = area.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
          htmlOutput += `  ${coord}\n`;
          textOutput += `  ${coord}\n`;
        }
        htmlOutput += '\n';
        textOutput += '\n';
      }

      // ðŸ”µ Lines
      const lines = xmlDoc.getElementsByTagName('line');
      for (let line of lines) {
        const name = line.getAttribute('name') || '(No name)';
        const attr = line.querySelector('attribute');
        const type = attr ? attr.getAttribute('lineType') : '(no type)';
        htmlOutput += `<span class="bullet line">â€¢</span>LINE: ${name}\n  Type: ${type}\n`;
        textOutput += `LINE: ${name}\n  Type: ${type}\n`;
        const vertices = line.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
          htmlOutput += `  ${coord}\n`;
          textOutput += `  ${coord}\n`;
        }
        htmlOutput += '\n';
        textOutput += '\n';
      }

      // ðŸŸ¢ Circles
      const circles = xmlDoc.getElementsByTagName('circle');
      for (let circle of circles) {
        const name = circle.getAttribute('name') || '(No name)';
        const attr = circle.querySelector('attribute');
        let range = attr ? attr.getAttribute('range') : '(no range)';
        if (!isNaN(range)) range = parseFloat(range).toFixed(2);
        htmlOutput += `<span class="bullet circle">â€¢</span>CIRCLE: ${name}\n  Range: ${range} NM\n`;
        textOutput += `CIRCLE: ${name}\n  Range: ${range} NM\n`;

        const v = circle.querySelector('vertex');
        if (v) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
          htmlOutput += `  Center: ${coord}\n`;
          textOutput += `  Center: ${coord}\n`;
        }
        htmlOutput += '\n';
        textOutput += '\n';
      }

      // ðŸŸ¤ Coast Lines
      const coasts = xmlDoc.getElementsByTagName('coastline');
      for (let coast of coasts) {
        const name = coast.getAttribute('name') || '(No name)';
        htmlOutput += `<span class="bullet coast">â€¢</span>COAST LINE: ${name}\n`;
        textOutput += `COAST LINE: ${name}\n`;
        const vertices = coast.getElementsByTagName('vertex');
        for (let v of vertices) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
          htmlOutput += `  ${coord}\n`;
          textOutput += `  ${coord}\n`;
        }
        htmlOutput += '\n';
        textOutput += '\n';
      }

      // ðŸŸ£ Labels
      const labels = xmlDoc.getElementsByTagName('label');
      for (let label of labels) {
        const name = label.getAttribute('name') || '(No name)';
        const text = label.textContent.trim() || '(no text)';
        const v = label.querySelector('vertex');
        htmlOutput += `<span class="bullet label">â€¢</span>LABEL: ${name}\n  Text: ${text}\n`;
        textOutput += `LABEL: ${name}\n  Text: ${text}\n`;
        if (v) {
          const lat = parseFloat(v.getAttribute('latitude'));
          const lon = parseFloat(v.getAttribute('longitude'));
          const coord = `${toDM(lat, true)}, ${toDM(lon, false)}`;
          htmlOutput += `  Position: ${coord}\n`;
          textOutput += `  Position: ${coord}\n`;
        }
        htmlOutput += '\n';
        textOutput += '\n';
      }

      parsedOutput = textOutput;
      document.getElementById('result').innerHTML = htmlOutput || 'No recognized elements found.';
    } catch (error) {
      document.getElementById('result').textContent = `Error: ${error.message}`;
    }
  }

  function downloadTextFile() {
    if (!parsedOutput) {
      alert("Nothing to download. Please parse XML first.");
      return;
    }
    const blob = new Blob([parsedOutput], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'parsed_coordinates.txt';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
</script>

</body>
</html>
